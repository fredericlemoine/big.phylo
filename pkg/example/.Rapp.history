as.numeric( sapply(bs.blocks.s,function(x)		3*x+c(1,2,3)		) )
?break
2.5*2 + 4.1*3 + 3.9*3.6 +4*3.7 + 4*3.9 + 2.8*3.5 +2.8*2.5
2.5*2 + 4.1*3 + 3.9*3.6 +4*3.7 + 4*3.9 + 2.8*3.5 +2.8*2.5 + 3.8*2
550 / 425
575 / 500
500 *1.3
525 / 425
500 * 1.235
525 / 450
500 * 1.17
105/3
choose(0,0)
pop<- 55011
perc.hiv<- 0.18
perc.adult<- 0.5
inc<- 0.0056
pop.s<- pop * (1-perc.hiv)
pop.s * 3 * inc
perc.hivcov<- 0.28
pop.s<- pop * (1-perc.hiv*perc.hivcov)
perc.hivcov<- 0.28
pop.s * 3 * inc
1714 * 0.5
pop<- 55011; perc.hiv<- 0.18; perc.adult<- 0.5; inc<- 0.0056; perc.hivcov<- 0.28
pop.s<- pop * perc.adult * (1-perc.hiv)
pop.s * 3 * inc
pop.s<- pop * (1-perc.hiv*perc.hivcov)
pop.s * 3 * inc
pop.s<- pop * perc.adult * (1-perc.hiv*perc.hivcov)
pop.s * 3 * inc
pop<- 55011; perc.hiv<- 0.18; perc.adult<- 0.5; inc<- 0.0075; perc.hivcov<- 0.28
pop.s<- pop * perc.adult * (1-perc.hiv)
pop.s * 3 * inc
pop<- 55011; perc.hiv<- 0.18; perc.adult<- 0.5; inc<- 0.01; perc.hivcov<- 0.28
pop.s<- pop * perc.adult * (1-perc.hiv)
pop.s * 3 * inc
1714*0.5 / (3*inc)
pop.s<- pop * perc.adult * (1-perc.hiv*perc.hivcov)
pop.s * 3 * inc
1714 / 2
pop.s * 3 * inc
83.7*83.7
83.7*83.7/100/100
45/12
require(roxygen2)
CODE.HOME	<<- "/Users/Oliver/git/recombination-anaylyzer/pkg"
roxygenize(CODE.HOME)
CODE.HOME	<<- "/Users/Oliver/git/recombination-analyzer/pkg"
roxygenize(CODE.HOME)
CODE.HOME	<<- "/Users/Oliver/git/recombination.analyzer/pkg"
roxygenize(CODE.HOME)
require(recombination.analyzer)
data.table()
library(recombination.analyzer)
data.table()
require(recombination.analyzer)
system.file(package='recombination.analyzer', "data", "mtDNA.phylip")
?read.dna
file<- system.file(package='recombination.analyzer', "data", "mtDNA.phylip")
read.dna(file)
read.dna(system.file(package='recombination.analyzer', "data", "neisseria.phylip"))
system.file(package='recombination.analyzer', "data", "neisseria.phylip")
read.dna("~/git/recombination.analyzer/pkg/data/neisseria.phylip")
?read.dna
read.dna("~/git/recombination.analyzer/pkg/data/neisseria.phylip", format="sequential")
read.dna(system.file(package='recombination.analyzer', "data", "mtDNA.phylip"), format="sequential")
?save
seq		<- system.file(package='recombination.analyzer', "data", "mtDNA.phylip")#
		seq		<- read.dna(seq, format='sequential')#
		file	<- system.file(package='recombination.analyzer', "data", "mtDNA.rds")#
		cat(paste('\nsave seq to file=',file))
seq
seq		<- system.file(package='recombination.analyzer', "data", "mtDNA.phylip")
seq
seq		<- read.dna(seq, format='sequential')
?system.file
file		<- system.file(package='recombination.analyzer', "data")
file
file	<- paste(system.file(package='recombination.analyzer', "data"), "/mtDNA.rds",sep='')#
		cat(paste('\nsave seq to file=',file))#
		saveRDS(seq, file=file)
?data
data(package='recombination.analyzer')
file	<- system.file(package='recombination.analyzer', "data", "mtDNA.phylip")#
		seq		<- read.dna(file, format='sequential')#
		file	<- paste(system.file(package='recombination.analyzer', "data"), "/mtDNA.rda",sep='')#
		cat(paste('\nsave seq to file=',file))#
		save(seq, file=file)
data(package='recombination.analyzer')
CODE.HOME	<<- "/Users/Oliver/git/recombination.analyzer/pkg"
file	<- paste(CODE.HOME,'/data/mtDNA.phylip',sep='')#
		seq		<- read.dna(file, format='sequential')#
		file	<- paste(CODE.HOME,'/data/mtDNA.rda',sep='')#
		cat(paste('\nsave seq to file=',file))#
		save(seq, file=file)
require(ape)#
	files	<- c( 	paste(CODE.HOME,'/data/mtDNA.phylip',sep=''),	#
					paste(CODE.HOME,'/data/den2.phylip',sep=''),#
					paste(CODE.HOME,'/data/neisseria.phylip',sep=''),#
					paste(CODE.HOME,'/data/nz_h1n1.phylip',sep=''),#
					paste(CODE.HOME,'/data/nzh3n2.phylip',sep='')		)#
	dummy	<- lapply(files, function(file)#
			{#
				seq		<- read.dna(file, format='sequential')#
				file	<- paste(CODE.HOME,'/data/mtDNA.rda',sep='')#
				cat(paste('\nsave seq to file=',file))#
				save(seq, file=file)				#
			})
files	<- c( 	'mtDNA','den2','neisseria','nz_h1n1','nzh3n2'	)#
	dummy	<- lapply(files, function(x)#
			{#
				cat(paste('\nprocess',x))#
				file	<- paste(CODE.HOME,'/data/',x,'.phylip',sep='')				#
				seq		<- read.dna(file, format='sequential')#
				file	<- paste(CODE.HOME,'/data/',x,'.rda',sep='')#
				cat(paste('\nsave seq to file=',file))#
				save(seq, file=file)				#
			})
read.dna( "/Users/Oliver/git/recombination.analyzer/pkg/data/nz_h1n1.phylip" )
files	<- c('nz_h1n1','nzh3n2')#
	dummy	<- lapply(files, function(x)#
			{#
				cat(paste('\nprocess',x))#
				file	<- paste(CODE.HOME,'/data/',x,'.phylip',sep='')				#
				seq		<- read.dna(file, format='interleaved')#
				file	<- paste(CODE.HOME,'/data/',x,'.rda',sep='')#
				cat(paste('\nsave seq to file=',file))#
				save(seq, file=file)				#
			})
files	<- c('nz_h1n1','nz_h3n2')#
	dummy	<- lapply(files, function(x)#
			{#
				cat(paste('\nprocess',x))#
				file	<- paste(CODE.HOME,'/data/',x,'.phylip',sep='')				#
				seq		<- read.dna(file, format='interleaved')#
				file	<- paste(CODE.HOME,'/data/',x,'.rda',sep='')#
				cat(paste('\nsave seq to file=',file))#
				save(seq, file=file)				#
			})
q()
require(abc.n)
alpha		<- 0.01#
scale		<- n.of.x<- 60#
df			<- 299#
tmp			<- nabc.chisqstretch.calibrate.taulow(2, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.1, 5, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, length(x), df, tmp["cl"], tmp["cu"])#
plot(rho,pw,col="black", type='l')#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.8, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, length(x), df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="blue")#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.5, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, length(x), df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="red")#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.3, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, length(x), df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="green")
alpha		<- 0.01#
scale		<- n.of.x<- 60#
df			<- 299#
tmp			<- nabc.chisqstretch.calibrate.taulow(2, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.1, 5, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, length(x), df, tmp["cl"], tmp["cu"])#
plot(rho,pw,col="black", type='l')
alpha		<- 0.01#
scale		<- n.of.x<- 60#
df			<- 299#
tmp			<- nabc.chisqstretch.calibrate.taulow(2, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.1, 5, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])#
plot(rho,pw,col="black", type='l')
alpha		<- 0.01#
scale		<- n.of.x<- 60#
df			<- 299#
tmp			<- nabc.chisqstretch.calibrate.taulow(2, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.1, 5, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])#
plot(rho,pw,col="black", type='l')#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.8, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="blue")#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.5, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="red")#
tmp			<- nabc.chisqstretch.calibrate.taulow(1.3, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])#
lines(rho,pw,col="green")
alpha		<- 0.01#
scale		<- n.of.x<- 60#
n.of.y		<- 299#
df			<- n.of.y-1#
x			<- rnorm(n.of.x,0,1)#
s.of.x		<- sd(x)#
#
tmp			<- nabc.chisqstretch.calibrate.tauup(mx.pw, 3*s.of.x, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.1, 5, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])		#
plot(rho,pw,col="black", type='l')
tmp			<- nabc.chisqstretch.calibrate.tauup(mx.pw, 3*s.of.x, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.4, 2, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])		#
plot(rho,pw,col="black", type='l')
tmp			<- nabc.chisqstretch.calibrate.tauup(0.9, 3*s.of.x, scale, df, alpha, rho.star=1, tol= 1e-5, max.it=100, verbose=1)#
rho			<- seq(0.4, 2, len=1024)#
pw			<- nabc.chisqstretch.pow(rho, n.of.x, df, tmp["cl"], tmp["cu"])		#
plot(rho,pw,col="black", type='l')
require(abc.n)
alpha	<- 0.01#
tau.u	<- 0.09#
tau.l	<- -tau.u#
sim.n	<-	5e3#
rho		<- seq(tau.l,tau.u,0.001)#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
#
plot(rho,pw,col="red", type='l')
require(abc.n)
alpha	<- 0.01#
tau.u	<- 0.09#
tau.l	<- -tau.u#
sim.n	<-	5e3#
rho		<- seq(tau.l,tau.u,0.001)#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
#
plot(rho,pw,col="red", type='l')
sim.n	<-	5e2#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
lines(rho,pw,col="blue")
sim.n	<-	1e4#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
lines(rho,pw,col="green")
alpha	<- 0.01#
tau.u	<- 0.09#
tau.l	<- -tau.u#
sim.n	<-	5e3#
rho		<- seq(tau.l,tau.u,0.001)#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
plot(rho,pw,col="red", ylim=c(0,1), type='l')#
#	flat power function when the number of simulated summary values is much lower	#
sim.n	<-	5e2#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
lines(rho,pw,col="blue")#
#	flat power function when the number of simulated summary values is much higher	#
sim.n	<-	2e4#
pw		<- corrz.pow(rho, tau.u, alpha, 1/sqrt(floor(sim.n/3)-3))#
lines(rho,pw,col="green")
?chisqstretch.sulkl
require(abc.n)
xa				<- 0.1#
xsigma2			<- 1	#
xn				<- 150	#
#	generate an MA(1) pseudo data set such that the sample autocorrelation and variance are very close to the true values#
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, verbose=0)
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, tol=6e-3, verbose=0)
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, tol=1e-2, verbose=0)
require(data.table)
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, tol=1e-2, verbose=0)
ma.get.pseudo.data<- function(n, mu, a, sd, leave.out.a=2, leave.out.s2=1, verbose=0, tol=2e-3, return_eps_0=FALSE )#
{#
	require(data.table)#
	verbose				<- 1#
	m					<- ceiling( max(1, n / 5000) )#
	m					<- 1e4 / m#
	#true values to match in observed data#
	rho.a.0				<- ma.a2rho(a)#
	rho.sig2.0			<- sd*sd *( 1 + a*a )#
	ans					<- NA#
	index.leave.out.s2	<- seq.int(1,n,by=1+leave.out.s2)#
	while(any(is.na(ans)))#
	{#
		x				<- rnorm(m*n+1,mu,sd=sd)#
		u0	 			<- x[seq(1,m*n,by=n)]#
		x				<- x[-1] + x[-(m*n+1)]*a#
		x				<- matrix(x,ncol=m)	#
		#adjust variance of time series#
		x_std_cte 		<- sapply(seq_len(ncol(x)),function(i)		sqrt(	((1+a*a)*sd*sd)/(var(x[index.leave.out.s2,i])*(n-1)/n)	)	)#
		x				<- sapply(seq_len(ncol(x)),function(i)		x[,i]*x_std_cte[i]							)			#set desired variance		#
		#compute sample autocorrelation with leave.out#
		if(leave.out.a)				#
			rho.a.x.lo		<- apply(x,2,function(col)	ma.cor(col, leave.out=leave.out.a)["z"] )#
		else#
			rho.a.x.lo		<- rep(rho.a.0, ncol(x))#
		#compute sample autocorrelation without leave.out #
		rho.a.x.nlo			<- apply(x,2,function(col)	ma.cor(col, leave.out=0)["z"] )#
		#compute sample variance without leave.out#
		if(leave.out.s2)	#
			rho.sig2.x.nlo	<- apply(x,2,function(col) var(col) )#
		else#
			rho.sig2.x.nlo	<- rep(rho.sig2.0, ncol(x))#
		error		<- sapply(seq_len(ncol(x)),function(i)#
				{ #
					tmp<- arima(x[,i], order=c(0,0,1), include.mean=0, method="CSS-ML")#
					c( tmp[["coef"]][1], tmp[["sigma2"]] )#
				})#
		error		<- t( abs(error-c(a,sd*sd)) )#
		colnames(error)	<- c("error.arima.a","error.arima.sd")#
		error		<- cbind( data.table( error ), data.table(	error.abc.a.lo=abs(rho.a.x.lo - rho.a.0 ), #
						error.abc.a.nlo=abs(rho.a.x.nlo - rho.a.0 ),#
						error.abc.sig2.nlo=abs(rho.sig2.x.nlo - rho.sig2.0),#
						u0= u0/x_std_cte), dummy=seq_along(u0) )#
		error		<- subset(error, error.arima.a<tol & error.arima.sd<tol &  error.abc.a.lo<tol  &  error.abc.a.nlo<tol & error.abc.sig2.nlo<tol)#
		if(nrow(error))#
		{#
			print(error)#
			str(error)#
			ans		<- error[1,dummy]#
			print(ans)#
			ans		<- x[,ans]#
		}#
		else if(verbose)	cat(paste("\nerror above",tol))						#
	}	#
	if(verbose && leave.out.a)	cat(paste("\n atanh(cor) of leave-out time series is",ma.cor(ans, leave.out=leave.out.a)["z"],"and should be",rho.a.0))	#
	if(verbose && leave.out.s2)	cat(paste("\n var*(n-1)/n of leave-out time series is",var(ans[index.leave.out.s2])*(n-1)/n,"and should be",rho.sig2.0))#
	tmp				<- arima(ans, order=c(0,0,1), include.mean=0, method="CSS-ML")#
	if(verbose)	cat(paste("\narima MLE of time series is a=",tmp[["coef"]][1],"sig2=",tmp[["sigma2"]]))#
	if(return_eps_0)#
	{#
		unthinned <- list(MLE=data.frame(a=tmp[["coef"]][1],sig2=tmp[["sigma2"]]),s_stat=data.frame(variance= var(ans),autocorr= ma.cor(ans)[["cor"]]))#
		thinned <- list(MLE=data.frame(a=NA,sig2=NA),s_stat=data.frame(variance= var(ans[index.leave.out.s2]),autocorr= ma.cor(ans,leave.out=leave.out.a)[["cor"]]))#
		ans_error <- as.data.frame(error[1,c(error.arima.a, error.arima.sd, error.abc.a.lo,error.abc.a.nlo,error.abc.sig2.nlo)])#
		ans <- list(param=data.frame(a=a,sig2=sd*sd),eps_0=error[1,u0],n=n,thin=data.frame(variance= leave.out.s2,autocorr= leave.out.a), unthinned=unthinned, thinned=thinned, precision=list(tol=tol,error=ans_error),x=ans)#
	}#
	ans#
}
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, tol=5e-2, verbose=0)
x				<- ma.get.pseudo.data(xn, 0, xa, xsigma2, tol=1e-2, verbose=0)
require(abc.star)
data(abc.star)
library(help=abc.star)
?data
data(package='abc.star')
data(ma_mcmc_a=0.1)
data('ma_mcmc_a=0.1')
x<- data('ma_mcmc_a=0.1')
str(x)
str(ma_exact)
str(ma.exact)
tmp			<- list.files(dir.name, pattern="^nABC.MA1_yncalibrated_")#
	tmp			<- sapply(strsplit(tmp,'_'), function(x)	tail(x,1) )#
	f.name.end	<- tmp[substr(tmp,1,1)=='a']#
	tmp			<- data.table(file=list.files(dir.name, pattern=".R$"))#
	files		<- tmp[,	{#
				f.name.end.idx<- sapply(f.name.end, function(z)		grepl(z,file))#
				list(a= ifelse(any(f.name.end.idx), f.name.end[f.name.end.idx], NA_character_))#
			},by=file]#
	files		<- subset(files, !is.na(a))[, list(a=substr(a,2,nchar(a)-2)) ,by=file]#
	set(files, NULL, 'a', as.numeric(files[,a]))#
	setkey(files, 'a')		#
	files		<- files[,	{#
				tmp<- strsplit(file,'_')[[1]]#
				list(cali= tmp[2], N=tmp[3], a=a)#
			}, by=file]#
	files		<- files[,		{#
				tmp<- ifelse(length(N)<2,1,2)#
				list( file= file[tmp] )#
			}	,by=c('a','cali')]
dir.name				<- paste("/Users/Oliver/workspace_sandbox/phylody/data","nABC.acf",sep='/')
tmp			<- list.files(dir.name, pattern="^nABC.MA1_yncalibrated_")#
	tmp			<- sapply(strsplit(tmp,'_'), function(x)	tail(x,1) )#
	f.name.end	<- tmp[substr(tmp,1,1)=='a']#
	tmp			<- data.table(file=list.files(dir.name, pattern=".R$"))#
	files		<- tmp[,	{#
				f.name.end.idx<- sapply(f.name.end, function(z)		grepl(z,file))#
				list(a= ifelse(any(f.name.end.idx), f.name.end[f.name.end.idx], NA_character_))#
			},by=file]#
	files		<- subset(files, !is.na(a))[, list(a=substr(a,2,nchar(a)-2)) ,by=file]#
	set(files, NULL, 'a', as.numeric(files[,a]))#
	setkey(files, 'a')		#
	files		<- files[,	{#
				tmp<- strsplit(file,'_')[[1]]#
				list(cali= tmp[2], N=tmp[3], a=a)#
			}, by=file]#
	files		<- files[,		{#
				tmp<- ifelse(length(N)<2,1,2)#
				list( file= file[tmp] )#
			}	,by=c('a','cali')]
files
dummy					<- sapply(xas, function(xa)#
			{#
				files.a<- subset(files,a==xa)#
				print(files.a)#
			})
xas						<- c(0, 0.1, 0.25)
dummy					<- sapply(xas, function(xa)#
			{#
				files.a<- subset(files,a==xa)#
				print(files.a)#
			})
dummy					<- sapply(xas, function(xa)#
			{#
				files.a<- subset(files,a==xa)#
				print(files.a)#
				cat(paste("\nprocess",xa)) 						#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				f.name					<- paste(dir.name, files.a[2,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				f.name					<- paste(dir.name, files.a[3,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))			#
			})
save abc star approximation to package#
	dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ma.abc.star				<- ans.ok#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star_a=",xa,".rda",sep='')#
				save(ma.abc.star, file=file)									#
			})
dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[3,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ma.abc.std				<- ans.eq#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.std_a=",xa,".rda",sep='')#
				save(ma.abc.std, file=file)									#
			})
dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[2,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ma.abc.star.ignoreautocorr		<- ans.ok.nlo#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star.ignore.autocorr_a=",xa,".rda",sep='')#
				save(ma.abc.star.ignoreautocorr, file=file)									#
			})
load('/Users/Oliver/workspace_sandbox/phylody/data/nABC.acf/nABC.MA1_yncalibratednoleaveout_5e+06_150_-0.5_0.5_0.1_0.3_1.7_1.1_a0.R')
str(ans.ok.nlo)
rownames(ans.ok.nlo$data)
file<- paste("/Users/Oliver/git/abc.n/pkg/data/","test_a=",xa,".rda",sep='')
file<- paste("/Users/Oliver/git/abc.n/pkg/data/","test_a=",0,".rda",sep='')
file
?save
save(ans.ok.nlo, compress='xz', file=file)
save(ans.ok.nlo, compress='bzip2', file=file)
ans.ok.nlo$data[,1:10]*1e4
ans.ok.nlo$data[,1:10]
ans.ok.nlo$data[1:2,1:10]*1e4
round( ans.ok.nlo$data[,1:10]*1e4, d=0 )
test<- round( ans.ok.nlo$data*1e4, d=0 )
?integer
test<- integer(test)
?integer
test<- as.integer(test)
test[,1:10]
test[1:10]
range(test)
save(test, compress='bzip2', compression_level=9, file=file)
library(bigmemory)
?big.matrix
test	<- round( ans.ok.nlo$data*1e4, d=0 )	#
	test	<- big.matrix(nrow(test),ncol(test), dimnames=list(rownames(test),colnames(test)), type="integer", init=NA)
test
test[,1:10]
test	<- round( ans.ok.nlo$data*1e4, d=0 )	#
	test2	<- big.matrix(nrow(test),ncol(test), dimnames=list(rownames(test),colnames(test)), type="integer", init=NA)#
	for(i in seq_len(nrow(test)))#
		test2[i,]	<- as.integer(test[i,])
test2[,1:10]
save(test2, compress='bzip2', compression_level=9, file=file)
?write.big.matrix
file
write.big.matrix(test2, file, row.names= 1, col.names=0, sep=',', type='integer')
write.big.matrix(test2, file, row.names= 1, col.names=0, sep=',')
test	<- as.integer(round( ans.ok.nlo$data[c("th.a","T.a", "th.s2","T.s2"),]*1e4, d=0 ))
save(test, compress='bzip2', compression_level=9, file=file)
dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ma.abc.star				<- as.integer(round( ans.ok$data[c("th.a","T.a", "th.s2","T.s2"),]*1e4, d=0 ))#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star_a=",xa,".rda",sep='')#
				save(ma.abc.star, file=file)									#
			})
require(abc.star)
xa				<- 0.1#
xsigma2			<- 1	#
xn				<- 150#
#	load precomputed MCMC output targeting the exact posterior for a=0.1, sig2=1, n=150#
#	in object 'ma.exact'#
#	see also 'data(package='abc.star')'#
data('ma_mcmc_a=0.1')#
data('ma_abc.star_a=0.1')
matrix(ma.abc.star, nrow=4, dimnames=list(c("th.a","T.a", "th.s2","T.s2"),c()) )
tmp<- matrix(ma.abc.star, nrow=4, dimnames=list(c("th.a","T.a", "th.s2","T.s2"),c()) )
tmp[,1:10]
tmp<- matrix(ma.abc.star, nrow=4, dimnames=list(c("th.a","T.a", "th.s2","T.s2"),c()) ) / 1e4
tmp[,1:10]
ma.abc.star		<- matrix(ma.abc.star, nrow=4, dimnames=list(c("th.a","T.a", "th.s2","T.s2"),c()) ) / 1e4
ma.a2rhofunction(ma.abc.star['th.a',1:10], ax = 0)
require(abc.star)
ma.a2rhofunction(ma.abc.star['th.a',1:10], ax = 0)
ma.a2rho <- function(a, ax = 0) #
{#
	atanh(a/(1 + a * a)) - atanh(ax)#
}
ma.a2rhofunction(ma.abc.star['th.a',1:10], ax = 0)
ma.a2rho(ma.abc.star['th.a',1:10], ax = 0)
ma.abc.star['rho.a',]	<- ma.a2rho(ma.abc.star['th.a',], ax = 0)
ma.abc.star				<- rbind(ma.abc.star, rho.a=ma.a2rho(ma.abc.star['th.a',], ax = 0))
ma.abc.star[,1:10]
rownames(ans.ok.nlo$data)
ma.abc.star				<- rbind(ma.abc.star, rho.s2=ma.sig22rho(ma.abc.star['th.s2',], ma.abc.star['rho.a',], vx=1))
ma.abc.star[,1:10]
load('~/workspace_sandbox/phylody/data/nABC.acf/nABC.MA1_yncalibrated_5e+06_150_-0.5_0.5_0.1_0.3_1.7_1.1_a0.1.R')
ans.ok$data[,1:10]
dir.name
dir.name				<- paste("/Users/Oliver/workspace_sandbox/phylody/data","nABC.acf",sep='/')#
	xas						<- c(0.1, 0.25)
tmp			<- list.files(dir.name, pattern="^nABC.MA1_yncalibrated_")#
	tmp			<- sapply(strsplit(tmp,'_'), function(x)	tail(x,1) )#
	f.name.end	<- tmp[substr(tmp,1,1)=='a']#
	tmp			<- data.table(file=list.files(dir.name, pattern=".R$"))#
	files		<- tmp[,	{#
				f.name.end.idx<- sapply(f.name.end, function(z)		grepl(z,file))#
				list(a= ifelse(any(f.name.end.idx), f.name.end[f.name.end.idx], NA_character_))#
			},by=file]#
	files		<- subset(files, !is.na(a))[, list(a=substr(a,2,nchar(a)-2)) ,by=file]#
	set(files, NULL, 'a', as.numeric(files[,a]))#
	setkey(files, 'a')		#
	files		<- files[,	{#
				tmp<- strsplit(file,'_')[[1]]#
				list(cali= tmp[2], N=tmp[3], a=a)#
			}, by=file]#
	files		<- files[,		{#
				tmp<- ifelse(length(N)<2,1,2)#
				list( file= file[tmp] )#
			}	,by=c('a','cali')]
files
dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ans.ok$data				<- as.integer(round( ans.ok$data*1e4, d=0 ))#
				ma.abc.star				<- ans.ok					#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star_a=",xa,".rda",sep='')#
				save(ma.abc.star, file=file, compress='bzip2', compression_level=9)									#
			})
xas<- c(0.1)#
	dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ans.ok$data				<- as.integer(round( ans.ok$data[1:1e6,]*1e4, d=0 ))#
				ma.abc.star				<- ans.ok					#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star_a=",xa,".rda",sep='')#
				save(ma.abc.star, file=file, compress='bzip2', compression_level=9)									#
			})
xas<- c(0.1)#
	dummy					<- sapply(xas, function(xa)#
			{#
				cat(paste("\nprocess",xa))#
				files.a<- subset(files,a==xa)#
				f.name					<- paste(dir.name, files.a[1,file],sep='/')#
				cat(paste("\nload ",f.name))#
				options(show.error.messages = FALSE, warn=1)		#
				readAttempt				<-try(suppressWarnings(load(f.name)))						#
				options(show.error.messages = TRUE)#
				cat(paste("\nloaded ",readAttempt))#
				ans.ok$data				<- as.integer(round( ans.ok$data[,1:1e6]*1e4, d=0 ))#
				ma.abc.star				<- ans.ok					#
				file					<- paste("/Users/Oliver/git/abc.n/pkg/data/","ma_abc.star_a=",xa,".rda",sep='')#
				save(ma.abc.star, file=file, compress='bzip2', compression_level=9)									#
			})
require(abc.star)
xa				<- 0.1#
xsigma2			<- 1	#
xn				<- 150#
#	load precomputed MCMC output targeting the exact posterior for a=0.1, sig2=1, n=150#
#	in object 'ma.exact'#
#	see also 'data(package='abc.star')'#
data('ma_mcmc_a=0.1')#
data('ma_abc.star_a=0.1')#
#	convert data back to double#
ma.abc.star$data	<- matrix(ma.abc.star$data, nrow=6, dimnames=list(c("th.a","rho.a", "T.a", "th.s2", "rho.s2",  "T.s2"),c()) ) / 1e4
ma.abc.star$data[,1:10]
range(ma.abc.star$data[6,])
xa				<- 0.1#
xsigma2			<- 1	#
xn				<- 150#
#	load precomputed MCMC output targeting the exact posterior for a=0.1, sig2=1, n=150#
#	in object 'ma.exact'#
#	see also 'data(package='abc.star')'#
data('ma_mcmc_a=0.1')#
data('ma_abc.star_a=0.1')#
#	convert data back to double#
ma.abc.star$data	<- matrix(ma.abc.star$data, nrow=9, dimnames=list(c("th.a","rho.a", "T.a", "T.a2", "T.a3", "th.s2", "rho.s2",  "T.s2",  "T.s22"),c()) ) / 1e4
ma.abc.star$data[,1:10]
ma.get.2D.mode<- function(x,y,xlim=NA,ylim=NA,xlab='x',ylab='y',n.hists=5,nbin=2, nlevels=5, width.infl=0.25, gridsize=c(100,100), plot=0, contour.col="black", cols= head( rev(gray(seq(0,.95,len=trunc(50*1.4)))), 50), ...)#
{#
	if(any(is.na(xlim)))	xlim<- range(x)*1.05#
	if(any(is.na(ylim)))	ylim<- range(y)*1.05#
	bins<- bin2(cbind(x, y), ab=rbind(xlim,ylim),nbin=nbin*c(nclass.Sturges(x),nclass.Sturges(y)))#
	f <- ash2(bins,rep(n.hists,2))#
	mxidx<- c( (which.max(f$z)-1)%%nrow(f$z)+1, (which.max(f$z)-1)%/%ncol(f$z)+1 ) #row, col#
	mx<- c(		mean( f$x[ c(mxidx[1],ifelse(mxidx[1]<length(f$x),mxidx[1]+1,mxidx[1])) ] ),#
				mean( f$y[ c(mxidx[2],ifelse(mxidx[2]<length(f$y),mxidx[2]+1,mxidx[2])) ] )		)#
	if(plot==1)#
	{#
			image(f$x,f$y,f$z, col=cols, ...)				#
			contour(f$x,f$y,f$z,add=TRUE, nlevels= nlevels, col=contour.col)#
			points(mx, col="red", pch=19)#
	}	#
	mx#
}
require(ash)
x						<- ma.exact$data$x#
x.map					<- ma.get.2D.mode(moving.avg$posterior[,a],moving.avg$posterior[,sig2], xlim= c(-0.4,0.4),ylim=c(0.6,1/0.6),plot=0, nbin=10,  method="ash")					#
x.map.on.rho			<- ma.rho2a( moving.avg$data$unthinned$s_stat$autocorr )#
x.map.on.rho			<- c( x.map.on.rho, ma.rho2sig2( moving.avg$data$unthinned$s_stat$variance, x.map.on.rho ) )
x						<- ma.exact$data$x#
x.map					<- ma.get.2D.mode(ma.exact$posterior[,a],ma.exact$posterior[,sig2], xlim= c(-0.4,0.4),ylim=c(0.6,1/0.6),plot=0, nbin=10,  method="ash")					#
x.map.on.rho			<- ma.rho2a( ma.exact$data$unthinned$s_stat$autocorr )#
x.map.on.rho			<- c( x.map.on.rho, ma.rho2sig2( ma.exact$data$unthinned$s_stat$variance, x.map.on.rho ) )
x.map.on.rho
x.map
suppressWarnings({#
	zx					<- ma.cor(x, leave.out=leave.out.a)#
	abc.param.a.1		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=alpha, max.it=100, pow_scale=2, debug=F, plot=F)					#
	zx					<- ma.cor(x[-c(1,2)], leave.out=leave.out.a)#
	abc.param.a.3		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=alpha, max.it=100, pow_scale=2, debug=F, plot=F)					#
	vx					<- x[seq.int(1,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.1	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=alpha, max.it=100, debug=F, plot=F)#
	vx					<- x[seq.int(2,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.2	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=alpha, max.it=100, debug=F, plot=F)#
		})
leave.out.a		<- 2#
leave.out.sig2	<- 1
suppressWarnings({#
	zx					<- ma.cor(x, leave.out=leave.out.a)#
	abc.param.a.1		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=alpha, max.it=100, pow_scale=2, debug=F, plot=F)					#
	zx					<- ma.cor(x[-c(1,2)], leave.out=leave.out.a)#
	abc.param.a.3		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=alpha, max.it=100, pow_scale=2, debug=F, plot=F)					#
	vx					<- x[seq.int(1,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.1	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=alpha, max.it=100, debug=F, plot=F)#
	vx					<- x[seq.int(2,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.2	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=alpha, max.it=100, debug=F, plot=F)#
		})
suppressWarnings({#
	zx					<- ma.cor(x, leave.out=leave.out.a)#
	abc.param.a.1		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	zx					<- ma.cor(x[-c(1,2)], leave.out=leave.out.a)#
	abc.param.a.3		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	vx					<- x[seq.int(1,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.1	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
	vx					<- x[seq.int(2,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.2	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
		})
traceback()
chisqstretch.calibrate<- function(n.of.x, s.of.x, scale=n.of.x, n.of.y=n.of.x, mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
{	#
	KL.of.yn_ub<- KL.of.yn<- error <- curr.mx.pw <- tau.low <- cl <- cu	<- NA		#
	#KL for initial n.of.y#
	KL.of.yn		<- chisqstretch.calibrate.tolerances.getkl(n.of.x, s.of.x, scale, n.of.y-1, 3*s.of.x, mx.pw=mx.pw, alpha=alpha, pow_scale=1.5, calibrate.tau.u=T, plot=F)["KL_div"]	#
	#KL always decreases from n.of.x. Find upper bound yn.ub such that KL first increases again.	#
	curr.it 		<- max.it#
	yn.ub 			<- 2 * n.of.y		#
	KL.of.yn_ub		<- chisqstretch.calibrate.tolerances.getkl(n.of.x, s.of.x, scale, yn.ub-1, 3*s.of.x, mx.pw=mx.pw, alpha=alpha, pow_scale=1.5, calibrate.tau.u=T, plot=F)["KL_div"]		#
	while (KL.of.yn_ub < KL.of.yn && curr.it > 0) #
	{#
		#print(c(yn.ub, KL.of.yn_ub, KL.of.yn, curr.it))#
		curr.it 		<- curr.it - 1#
		KL.of.yn 		<- KL.of.yn_ub#
		yn.ub 			<- 2 * yn.ub#
		KL.of.yn_ub		<- chisqstretch.calibrate.tolerances.getkl(n.of.x, s.of.x, scale, yn.ub-1, 3*s.of.x, mx.pw=mx.pw, alpha=alpha, pow_scale=1.5, calibrate.tau.u=T, plot=F)["KL_div"]#
		if(debug)	cat(paste("\ntrial upper bound m=",yn.ub,"with KL",KL.of.yn_ub))#
	}			#
	if (curr.it == 0) 	stop("could not find upper bound for yn")					#
	if(debug)	cat(paste("\nFound upper bound m=",yn.ub,"with KL",KL.of.yn_ub))#
	yn.lb	<- ifelse(curr.it==max.it, yn.ub/2, yn.ub/4)#
	if(debug)	cat(paste("\nupper and lower bounds on m:",yn.lb, yn.ub))#
	KL_args					<- list(n.of.x=n.of.x, s.of.x=s.of.x, scale=scale, tau.u=3*s.of.x, mx.pw=mx.pw, alpha=alpha, calibrate.tau.u=T, plot=F)	#
	tmp 					<- optimize(kl.optimize, interval = c(yn.lb-1, yn.ub-1), x_name = "df", is_integer = T, KL_divergence = "chisqstretch.calibrate.tolerances.getkl", KL_args = KL_args, verbose = debug, tol = 1)#
	n.of.y 										<- round(tmp$minimum)+1#
	g(KL_div, tau.l, tau.u, c.l, c.u, pw.cmx)	%<-%	chisqstretch.calibrate.tolerances.getkl(n.of.x, s.of.x, scale, n.of.y-1, 3*s.of.x, mx.pw=mx.pw, alpha=alpha, pow_scale=1.5, calibrate.tau.u=T, plot=plot)#
	c(n.of.y=n.of.y, tau.l=tau.l, tau.u=tau.u, cl=c.l, cu=c.u, pw.cmx=pw.cmx, KL_div=KL_div)		#
}
suppressWarnings({#
	zx					<- ma.cor(x, leave.out=leave.out.a)#
	abc.param.a.1		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	zx					<- ma.cor(x[-c(1,2)], leave.out=leave.out.a)#
	abc.param.a.3		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	vx					<- x[seq.int(1,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.1	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
	vx					<- x[seq.int(2,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.2	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
		})
kl.optimize<- function(x_value, x_name, is_integer=FALSE, KL_divergence, KL_args, verbose=FALSE) #
{#
	if (verbose)		cat(paste("\nOptimizing x=",x_value))#
	if(is_integer)#
		x_value 		<- round(x_value)	#
	KL_args 			<- c(list(x_name = x_value),KL_args)#
	names(KL_args)[1] 	<- x_name#
	tmp					<- do.call(KL_divergence,KL_args)	#
	if(0 || !verbose)								#TODO anton check#
		options(warn=0)	#
	return(tmp["KL_div"])#
}
kl.integrand<-function(x,dP,dQ,P_arg,Q_arg)#
{#
	#this function must accept x as a vector	#
	log_P_x	<- do.call(dP,c(list(x,log=T),P_arg))				#
	log_Q_x	<- do.call(dQ,c(list(x,log=T),Q_arg))#
	if(any(tmp<-(log_Q_x == -Inf)))#
	{#
		cat("\nQ(x) is 0 at some point! Usually this happens due to numerical inacurracy in the tail of Q. For simplicity we assume that log(Q(x))=-100 at these points.")#
		log_Q_x[tmp]<- log(.Machine$double.xmin)#
	}#
	ans		<- (log_P_x-log_Q_x)*exp(log_P_x)#
	if(any(!is.finite(ans)))#
	{#
		print(data.frame(x,P_x=exp(log_P_x),log_P_x,log_Q_x,ans))#
		stop()#
	}			#
	return(ans)#
}
suppressWarnings({#
	zx					<- ma.cor(x, leave.out=leave.out.a)#
	abc.param.a.1		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	zx					<- ma.cor(x[-c(1,2)], leave.out=leave.out.a)#
	abc.param.a.3		<- corrz.calibrate(zx["n"], mx.pw=0.9, alpha=0.01, max.it=100, pow_scale=2, debug=F, plot=F)					#
	vx					<- x[seq.int(1,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.1	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
	vx					<- x[seq.int(2,length(x),by=1+leave.out.sig2)]#
	abc.param.sig2.2	<- chisqstretch.calibrate(length(vx), sd(vx), mx.pw=0.9, alpha=0.01, max.it=100, debug=F, plot=F)#
		})
setwd("/Users/Oliver/git/big.phylo/pkg/example")
require(big.phylo)#
data(nz_h3n2)#
#	H3N2 data is stored in 'seq' DNAbin matrix object#
print( seq )							#
#	write sequences to directory for processing#
indir		<- getwd()#
infile		<- 'nz_h3n2.R'#
insignat	<- ''#
save(seq, file=paste(indir, infile, sep='/'))	#
#	Create the first ExaML boostrap tree#
pipeline.ExaML.bootstrap.per.proc(indir, infile, bs.from=0, bs.to=0, hpc.walltime=1, hpc.q=NA, hpc.mem="500mb", hpc.nproc=1)
pipeline.ExaML.bootstrap.per.proc(indir, infile, bs.from=1, bs.to=2, hpc.walltime=1, hpc.q=NA, hpc.mem="500mb", hpc.nproc=1)
require(big.phylo)#
data(nz_h3n2)#
#	H3N2 data is stored in 'seq' DNAbin matrix object#
print( seq )							#
#	write sequences to directory for processing#
indir		<- getwd()#
infile		<- 'nz_h3n2.R'#
insignat	<- ''#
save(seq, file=paste(indir, infile, sep='/'))	#
#	create the command string#
bs.id		<- 0#
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))
argv
prog.examl.getbootstrapseq()
prog.examl.getbootstrapseq<- function()#
{		#
	indir				<- outdir		<- infile	<- ''	#
	verbose				<- resume		<- 1#
	opt.bootstrap.by	<- "codon"#
	bs					<- 0#
	check.any.bs.identical	<- 0#
	if(exists("argv"))#
	{#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,6),#
									indir= return(substr(arg,8,nchar(arg))),NA)	}))#
		if(length(tmp)>0) indir<- tmp[1]#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,7),#
									outdir= return(substr(arg,9,nchar(arg))),NA)	}))#
		if(length(tmp)>0) outdir<- tmp[1]#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,7),#
									infile= return(substr(arg,9,nchar(arg))),NA)	}))#
		if(length(tmp)>0) infile<- tmp[1]				#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,7),#
									resume= return(as.numeric(substr(arg,9,nchar(arg)))),NA)	}))#
		if(length(tmp)>0) resume<- tmp[1]#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,2),#
									v= return(as.numeric(substr(arg,4,nchar(arg)))),NA)	}))#
		if(length(tmp)>0) verbose<- tmp[1]#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,10),#
									bootstrap= return(as.numeric(substr(arg,12,nchar(arg)))),NA)	}))#
		if(length(tmp)>0) bs<- tmp[1]#
		tmp<- na.omit(sapply(argv,function(arg)#
						{	switch(substr(arg,2,3),#
									by= return(substr(arg,5,nchar(arg))),NA)	}))#
		if(length(tmp)>0) opt.bootstrap.by<- tmp[1]#
	}#
	if(verbose)#
	{#
		print( indir ) #
		print(outdir)#
		print(infile)#
		print(verbose)#
		print(resume)#
		print(bs)#
		print(opt.bootstrap.by)		#
	}#
	if(!opt.bootstrap.by%in%c("nucleotide","codon"))	stop("Unexpected opt.bootstrap.by")		#
	pattern 	<- paste(infile,".phylip.",sprintf("%03d",bs),sep='')#
	file		<- list.files(path=outdir, pattern=pattern, full.names=1)#
	if(!resume || !length(file))	#
	{					#
		file		<- paste(outdir,"/",infile,".R",sep='')#
		if(verbose) cat(paste("\nread",file))#
		tmp			<- load(file)#
		if(length(tmp)!=1)		#
			stop("Unexpected lenght of loaded objects")#
		eval(parse(text=paste("seq.PROT.RT<- ",tmp,sep='')))#
		if(!"DNAbin"%in%class(seq.PROT.RT) || !is.matrix(seq.PROT.RT))	#
			stop("expect R infile that contains a DNAbin matrix")#
		print(seq.PROT.RT)#
		#print(bs)#
		if(bs)		#keep bs0 intact#
		{#
			dummy			<- 0#
			any.eq			<- 1#
			j				<- 0#
			while(any.eq)#
			{#
				j			<- j+1#
				if(opt.bootstrap.by=="codon")#
				{#
					bs.blocks.n	<- floor( ncol(seq.PROT.RT )/3)#
					bs.blocks.s	<- sample(seq_len(bs.blocks.n),bs.blocks.n,replace=T)-1#
					bs.seq.s	<- as.numeric( sapply(bs.blocks.s,function(x)		3*x+c(1,2,3)		) )#
				}#
				else if(opt.bootstrap.by=="nucleotide")#
				{#
					bs.seq.s	<- sample(seq_len(ncol(seq.PROT.RT )),ncol(seq.PROT.RT ),replace=T)#
				}#
				seq.BS		<- seq.PROT.RT[,bs.seq.s]				#
				if(check.any.bs.identical)#
				{#
					if(verbose) cat(paste("\ncheck for identity proposed boostrap seq alignment no",j))#
					#check no seqs identical								#
					for(i1 in seq_len(nrow(seq.BS)-1))#
					{#
						seq1		<- seq.BS[i1,]#
						tmp			<- 1-sapply(seq.int(i1+1,nrow(seq.BS)),function(i2)#
													{		#
														.C("hivc_dist_ambiguous_dna", seq1, seq.BS[i2,], ncol(seq1), dummy )[[4]]			#
													})#
						#print(tmp)#
						if(any(tmp==0))#
						{#
							print(tmp)#
							break#
						}									#
						if(i1==nrow(seq.BS)-1)#
							any.eq	<- 0#
					}#
					if(verbose) cat(paste("\nchecked for identity proposed boostrap seq alignment no",j,"is any identical",any.eq))#
				}#
				else#
					any.eq	<- 0#
			}					#
		}#
		else#
		{#
			cat(paste("\nkeep boostrap seq alignment no",bs,"as original"))#
			seq.BS	<- seq.PROT.RT#
		}#
		file		<- paste(outdir,"/",infile,".phylip.",sprintf("%03d",bs),sep='')#
		cat(paste("\nsave boostrap seq alignment to",file))#
		seq.write.dna.phylip(seq.BS, file=file)#
	}#
	else#
		cat("\nfound boostrap sequence alignment")#
}
prog.examl.getbootstrapseq()
cmd.examl.bsalignment<- function(indir, infile, bs.id, outdir=indir, prog.bscreate= PR.EXAML.BSCREATE, opt.bootstrap.by="codon",resume=0, verbose=1)#
{#
	cmd			<- paste("########################################################
# start: create and check bootstrap alignment#
#######################################################\n",sep='')#
	cmd			<- paste(cmd,prog.bscreate," -resume=",resume," -bootstrap=",bs.id," -by=",opt.bootstrap.by,sep='')#
	cmd			<- paste(cmd," -indir=",indir," -infile=",infile," -outdir=",outdir,' ',sep='')	#
	cmd			<- paste(cmd,"\n########################################################
# end: create and check bootstrap alignment#
#######################################################",sep='')			#
	cmd#
}
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))#
#	create the bootstrap alignment#
prog.examl.getbootstrapseq()
PR.PACKAGE					<- "big.phylo"#
PR.STARTME					<- system.file(package=PR.PACKAGE, "misc", "startme.R") #
PR.EXAML.BSCREATE			<- paste(PR.STARTME,"-exe=BOOTSTRAPSEQ",sep=' ')#
PR.EXAML.PARSER				<- system.file(package=PR.PACKAGE, "ext", "ExaML-parser") #
PR.EXAML.STARTTREE			<- system.file(package=PR.PACKAGE, "ext", "ExaML-parsimonator")#
PR.EXAML.EXAML				<- system.file(package=PR.PACKAGE, "ext", "examl")#
PR.EXAML.BS					<- system.file(package=PR.PACKAGE, "ext", "ExaML-raxml")#
HPC.NPROC					<- {tmp<- c(1,4); names(tmp)<- c("debug","cx1.hpc.ic.ac.uk"); tmp}#
HPC.MPIRUN					<- {tmp<- c("mpirun","mpiexec"); names(tmp)<- c("debug","cx1.hpc.ic.ac.uk"); tmp}#
HPC.CX1.IMPERIAL			<- "cx1.hpc.ic.ac.uk"		#this is set to system('domainname',intern=T) for the hpc cluster of choice#
HPC.MEM						<- "1750mb"#
HPC.CX1.IMPERIAL.LOAD		<- "module load intel-suite mpi R/2.15"
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))#
#	create the bootstrap alignment#
prog.examl.getbootstrapseq()
infile		<- substr(infile, 1, nchar(infile)-2)#
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))
argv
prog.examl.getbootstrapseq()
bs.id		<- 1#
infile		<- substr(infile, 1, nchar(infile)-2)#
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))#
#	create the bootstrap alignment#
prog.examl.getbootstrapseq()
infile		<- 'nz_h3n2.R'
bs.id		<- 1#
infile		<- substr(infile, 1, nchar(infile)-2)#
argv		<<- cmd.examl.bsalignment(indir, infile, bs.id) #
argv		<<- unlist(strsplit(argv,' '))#
#	create the bootstrap alignment#
prog.examl.getbootstrapseq()
library(help="big.phylo")
CODE.HOME	<<- "/Users/Oliver/git/big.phylo/pkg"
paste( CODE.HOME,"/data/IAS_primarydrugresistance_201303.csv",sep='' )
file<- paste( CODE.HOME,"/data/IAS_primarydrugresistance_201303.csv",sep='' )
read.csv(file)
file	<- paste( CODE.HOME,"/data/IAS.csv",sep='' )
print(file)#
	dr		<- as.data.table( read.csv( file, stringsAsFactors=F ) )
dr
